// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class FlowEndMessage extends ethereum.Event {
  get params(): FlowEndMessage__Params {
    return new FlowEndMessage__Params(this);
  }
}

export class FlowEndMessage__Params {
  _event: FlowEndMessage;

  constructor(event: FlowEndMessage) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class FlowStartMessage extends ethereum.Event {
  get params(): FlowStartMessage__Params {
    return new FlowStartMessage__Params(this);
  }
}

export class FlowStartMessage__Params {
  _event: FlowStartMessage;

  constructor(event: FlowStartMessage) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get startTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class FlowTopupMessage extends ethereum.Event {
  get params(): FlowTopupMessage__Params {
    return new FlowTopupMessage__Params(this);
  }
}

export class FlowTopupMessage__Params {
  _event: FlowTopupMessage;

  constructor(event: FlowTopupMessage) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get newFlowRate(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get topupTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get endTime(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class RebalanceMessageSent extends ethereum.Event {
  get params(): RebalanceMessageSent__Params {
    return new RebalanceMessageSent__Params(this);
  }
}

export class RebalanceMessageSent__Params {
  _event: RebalanceMessageSent;

  constructor(event: RebalanceMessageSent) {
    this._event = event;
  }

  get amount(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class StreamDelete extends ethereum.Event {
  get params(): StreamDelete__Params {
    return new StreamDelete__Params(this);
  }
}

export class StreamDelete__Params {
  _event: StreamDelete;

  constructor(event: StreamDelete) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class StreamStart extends ethereum.Event {
  get params(): StreamStart__Params {
    return new StreamStart__Params(this);
  }
}

export class StreamStart__Params {
  _event: StreamStart;

  constructor(event: StreamStart) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get startTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class StreamUpdate extends ethereum.Event {
  get params(): StreamUpdate__Params {
    return new StreamUpdate__Params(this);
  }
}

export class StreamUpdate__Params {
  _event: StreamUpdate;

  constructor(event: StreamUpdate) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get startTime(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class UpgradeToken extends ethereum.Event {
  get params(): UpgradeToken__Params {
    return new UpgradeToken__Params(this);
  }
}

export class UpgradeToken__Params {
  _event: UpgradeToken;

  constructor(event: UpgradeToken) {
    this._event = event;
  }

  get baseToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class XReceiveData extends ethereum.Event {
  get params(): XReceiveData__Params {
    return new XReceiveData__Params(this);
  }
}

export class XReceiveData__Params {
  _event: XReceiveData;

  constructor(event: XReceiveData) {
    this._event = event;
  }

  get originSender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get origin(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get asset(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get transferId(): Bytes {
    return this._event.parameters[4].value.toBytes();
  }

  get receiveTimestamp(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get senderAccount(): Address {
    return this._event.parameters[6].value.toAddress();
  }

  get receiverAccount(): Address {
    return this._event.parameters[7].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }
}

export class XStreamFlowTrigger extends ethereum.Event {
  get params(): XStreamFlowTrigger__Params {
    return new XStreamFlowTrigger__Params(this);
  }
}

export class XStreamFlowTrigger__Params {
  _event: XStreamFlowTrigger;

  constructor(event: XStreamFlowTrigger) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get selectedToken(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get streamStatus(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get startTime(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }

  get bufferFee(): BigInt {
    return this._event.parameters[7].value.toBigInt();
  }

  get networkFee(): BigInt {
    return this._event.parameters[8].value.toBigInt();
  }

  get destinationDomain(): BigInt {
    return this._event.parameters[9].value.toBigInt();
  }
}

export class XStreamPool extends ethereum.SmartContract {
  static bind(address: Address): XStreamPool {
    return new XStreamPool("XStreamPool", address);
  }

  afterAgreementCreated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes,
    param5: Bytes
  ): Bytes {
    let result = super.call(
      "afterAgreementCreated",
      "afterAgreementCreated(address,address,bytes32,bytes,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4),
        ethereum.Value.fromBytes(param5)
      ]
    );

    return result[0].toBytes();
  }

  try_afterAgreementCreated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes,
    param5: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "afterAgreementCreated",
      "afterAgreementCreated(address,address,bytes32,bytes,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4),
        ethereum.Value.fromBytes(param5)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  afterAgreementTerminated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes,
    param5: Bytes
  ): Bytes {
    let result = super.call(
      "afterAgreementTerminated",
      "afterAgreementTerminated(address,address,bytes32,bytes,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4),
        ethereum.Value.fromBytes(param5)
      ]
    );

    return result[0].toBytes();
  }

  try_afterAgreementTerminated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes,
    param5: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "afterAgreementTerminated",
      "afterAgreementTerminated(address,address,bytes32,bytes,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4),
        ethereum.Value.fromBytes(param5)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  afterAgreementUpdated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes,
    param5: Bytes
  ): Bytes {
    let result = super.call(
      "afterAgreementUpdated",
      "afterAgreementUpdated(address,address,bytes32,bytes,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4),
        ethereum.Value.fromBytes(param5)
      ]
    );

    return result[0].toBytes();
  }

  try_afterAgreementUpdated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes,
    param5: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "afterAgreementUpdated",
      "afterAgreementUpdated(address,address,bytes32,bytes,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4),
        ethereum.Value.fromBytes(param5)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  amount(): BigInt {
    let result = super.call("amount", "amount():(uint256)", []);

    return result[0].toBigInt();
  }

  try_amount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("amount", "amount():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  beforeAgreementCreated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "beforeAgreementCreated",
      "beforeAgreementCreated(address,address,bytes32,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_beforeAgreementCreated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "beforeAgreementCreated",
      "beforeAgreementCreated(address,address,bytes32,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  beforeAgreementTerminated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "beforeAgreementTerminated",
      "beforeAgreementTerminated(address,address,bytes32,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_beforeAgreementTerminated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "beforeAgreementTerminated",
      "beforeAgreementTerminated(address,address,bytes32,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  beforeAgreementUpdated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes
  ): Bytes {
    let result = super.call(
      "beforeAgreementUpdated",
      "beforeAgreementUpdated(address,address,bytes32,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );

    return result[0].toBytes();
  }

  try_beforeAgreementUpdated(
    param0: Address,
    param1: Address,
    param2: Bytes,
    param3: Bytes,
    param4: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "beforeAgreementUpdated",
      "beforeAgreementUpdated(address,address,bytes32,bytes,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromFixedBytes(param2),
        ethereum.Value.fromBytes(param3),
        ethereum.Value.fromBytes(param4)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  cfa(): Address {
    let result = super.call("cfa", "cfa():(address)", []);

    return result[0].toAddress();
  }

  try_cfa(): ethereum.CallResult<Address> {
    let result = super.tryCall("cfa", "cfa():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  connext(): Address {
    let result = super.call("connext", "connext():(address)", []);

    return result[0].toAddress();
  }

  try_connext(): ethereum.CallResult<Address> {
    let result = super.tryCall("connext", "connext():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  dedicatedMsgSender(): Address {
    let result = super.call(
      "dedicatedMsgSender",
      "dedicatedMsgSender():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_dedicatedMsgSender(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "dedicatedMsgSender",
      "dedicatedMsgSender():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  erc20Token(): Address {
    let result = super.call("erc20Token", "erc20Token():(address)", []);

    return result[0].toAddress();
  }

  try_erc20Token(): ethereum.CallResult<Address> {
    let result = super.tryCall("erc20Token", "erc20Token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  feeAccrualRate(): BigInt {
    let result = super.call("feeAccrualRate", "feeAccrualRate():(int96)", []);

    return result[0].toBigInt();
  }

  try_feeAccrualRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "feeAccrualRate",
      "feeAccrualRate():(int96)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  feesPending(): BigInt {
    let result = super.call("feesPending", "feesPending():(uint256)", []);

    return result[0].toBigInt();
  }

  try_feesPending(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("feesPending", "feesPending():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  flowRate(): BigInt {
    let result = super.call("flowRate", "flowRate():(int96)", []);

    return result[0].toBigInt();
  }

  try_flowRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("flowRate", "flowRate():(int96)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fundsOwner(): Address {
    let result = super.call("fundsOwner", "fundsOwner():(address)", []);

    return result[0].toAddress();
  }

  try_fundsOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall("fundsOwner", "fundsOwner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  host(): Address {
    let result = super.call("host", "host():(address)", []);

    return result[0].toAddress();
  }

  try_host(): ethereum.CallResult<Address> {
    let result = super.tryCall("host", "host():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  lastFeeAccrualUpdate(): BigInt {
    let result = super.call(
      "lastFeeAccrualUpdate",
      "lastFeeAccrualUpdate():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_lastFeeAccrualUpdate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastFeeAccrualUpdate",
      "lastFeeAccrualUpdate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ops(): Address {
    let result = super.call("ops", "ops():(address)", []);

    return result[0].toAddress();
  }

  try_ops(): ethereum.CallResult<Address> {
    let result = super.tryCall("ops", "ops():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  receiver(): Address {
    let result = super.call("receiver", "receiver():(address)", []);

    return result[0].toAddress();
  }

  try_receiver(): ethereum.CallResult<Address> {
    let result = super.tryCall("receiver", "receiver():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  sender(): Address {
    let result = super.call("sender", "sender():(address)", []);

    return result[0].toAddress();
  }

  try_sender(): ethereum.CallResult<Address> {
    let result = super.tryCall("sender", "sender():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  startTime(): BigInt {
    let result = super.call("startTime", "startTime():(uint256)", []);

    return result[0].toBigInt();
  }

  try_startTime(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("startTime", "startTime():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  streamActionType(): BigInt {
    let result = super.call(
      "streamActionType",
      "streamActionType():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_streamActionType(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "streamActionType",
      "streamActionType():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  superToken(): Address {
    let result = super.call("superToken", "superToken():(address)", []);

    return result[0].toAddress();
  }

  try_superToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("superToken", "superToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  taskTreasury(): Address {
    let result = super.call("taskTreasury", "taskTreasury():(address)", []);

    return result[0].toAddress();
  }

  try_taskTreasury(): ethereum.CallResult<Address> {
    let result = super.tryCall("taskTreasury", "taskTreasury():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  xReceive(
    _transferId: Bytes,
    _amount: BigInt,
    _asset: Address,
    _originSender: Address,
    _origin: BigInt,
    _callData: Bytes
  ): Bytes {
    let result = super.call(
      "xReceive",
      "xReceive(bytes32,uint256,address,address,uint32,bytes):(bytes)",
      [
        ethereum.Value.fromFixedBytes(_transferId),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_originSender),
        ethereum.Value.fromUnsignedBigInt(_origin),
        ethereum.Value.fromBytes(_callData)
      ]
    );

    return result[0].toBytes();
  }

  try_xReceive(
    _transferId: Bytes,
    _amount: BigInt,
    _asset: Address,
    _originSender: Address,
    _origin: BigInt,
    _callData: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "xReceive",
      "xReceive(bytes32,uint256,address,address,uint32,bytes):(bytes)",
      [
        ethereum.Value.fromFixedBytes(_transferId),
        ethereum.Value.fromUnsignedBigInt(_amount),
        ethereum.Value.fromAddress(_asset),
        ethereum.Value.fromAddress(_originSender),
        ethereum.Value.fromUnsignedBigInt(_origin),
        ethereum.Value.fromBytes(_callData)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class DefaultCall extends ethereum.Call {
  get inputs(): DefaultCall__Inputs {
    return new DefaultCall__Inputs(this);
  }

  get outputs(): DefaultCall__Outputs {
    return new DefaultCall__Outputs(this);
  }
}

export class DefaultCall__Inputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class DefaultCall__Outputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class _sendFlowMessageCall extends ethereum.Call {
  get inputs(): _sendFlowMessageCall__Inputs {
    return new _sendFlowMessageCall__Inputs(this);
  }

  get outputs(): _sendFlowMessageCall__Outputs {
    return new _sendFlowMessageCall__Outputs(this);
  }
}

export class _sendFlowMessageCall__Inputs {
  _call: _sendFlowMessageCall;

  constructor(call: _sendFlowMessageCall) {
    this._call = call;
  }

  get streamActionType(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get relayerFee(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get slippage(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get cost(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get bridgingToken(): Address {
    return this._call.inputValues[6].value.toAddress();
  }

  get destinationContract(): Address {
    return this._call.inputValues[7].value.toAddress();
  }

  get destinationDomain(): BigInt {
    return this._call.inputValues[8].value.toBigInt();
  }
}

export class _sendFlowMessageCall__Outputs {
  _call: _sendFlowMessageCall;

  constructor(call: _sendFlowMessageCall) {
    this._call = call;
  }
}

export class _sendToManyFlowMessageCall extends ethereum.Call {
  get inputs(): _sendToManyFlowMessageCall__Inputs {
    return new _sendToManyFlowMessageCall__Inputs(this);
  }

  get outputs(): _sendToManyFlowMessageCall__Outputs {
    return new _sendToManyFlowMessageCall__Outputs(this);
  }
}

export class _sendToManyFlowMessageCall__Inputs {
  _call: _sendToManyFlowMessageCall;

  constructor(call: _sendToManyFlowMessageCall) {
    this._call = call;
  }

  get receivers(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get flowRates(): Array<BigInt> {
    return this._call.inputValues[1].value.toBigIntArray();
  }

  get streamActionType(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get relayerFee(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get slippage(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get cost(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get bridgingToken(): Address {
    return this._call.inputValues[6].value.toAddress();
  }

  get destinationContract(): Address {
    return this._call.inputValues[7].value.toAddress();
  }

  get destinationDomain(): BigInt {
    return this._call.inputValues[8].value.toBigInt();
  }
}

export class _sendToManyFlowMessageCall__Outputs {
  _call: _sendToManyFlowMessageCall;

  constructor(call: _sendToManyFlowMessageCall) {
    this._call = call;
  }
}

export class AfterAgreementCreatedCall extends ethereum.Call {
  get inputs(): AfterAgreementCreatedCall__Inputs {
    return new AfterAgreementCreatedCall__Inputs(this);
  }

  get outputs(): AfterAgreementCreatedCall__Outputs {
    return new AfterAgreementCreatedCall__Outputs(this);
  }
}

export class AfterAgreementCreatedCall__Inputs {
  _call: AfterAgreementCreatedCall;

  constructor(call: AfterAgreementCreatedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get value3(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get value5(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class AfterAgreementCreatedCall__Outputs {
  _call: AfterAgreementCreatedCall;

  constructor(call: AfterAgreementCreatedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class AfterAgreementTerminatedCall extends ethereum.Call {
  get inputs(): AfterAgreementTerminatedCall__Inputs {
    return new AfterAgreementTerminatedCall__Inputs(this);
  }

  get outputs(): AfterAgreementTerminatedCall__Outputs {
    return new AfterAgreementTerminatedCall__Outputs(this);
  }
}

export class AfterAgreementTerminatedCall__Inputs {
  _call: AfterAgreementTerminatedCall;

  constructor(call: AfterAgreementTerminatedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get value3(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get value5(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class AfterAgreementTerminatedCall__Outputs {
  _call: AfterAgreementTerminatedCall;

  constructor(call: AfterAgreementTerminatedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class AfterAgreementUpdatedCall extends ethereum.Call {
  get inputs(): AfterAgreementUpdatedCall__Inputs {
    return new AfterAgreementUpdatedCall__Inputs(this);
  }

  get outputs(): AfterAgreementUpdatedCall__Outputs {
    return new AfterAgreementUpdatedCall__Outputs(this);
  }
}

export class AfterAgreementUpdatedCall__Inputs {
  _call: AfterAgreementUpdatedCall;

  constructor(call: AfterAgreementUpdatedCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get value3(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get value4(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }

  get value5(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class AfterAgreementUpdatedCall__Outputs {
  _call: AfterAgreementUpdatedCall;

  constructor(call: AfterAgreementUpdatedCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class ApproveSuperTokenCall extends ethereum.Call {
  get inputs(): ApproveSuperTokenCall__Inputs {
    return new ApproveSuperTokenCall__Inputs(this);
  }

  get outputs(): ApproveSuperTokenCall__Outputs {
    return new ApproveSuperTokenCall__Outputs(this);
  }
}

export class ApproveSuperTokenCall__Inputs {
  _call: ApproveSuperTokenCall;

  constructor(call: ApproveSuperTokenCall) {
    this._call = call;
  }

  get _asset(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveSuperTokenCall__Outputs {
  _call: ApproveSuperTokenCall;

  constructor(call: ApproveSuperTokenCall) {
    this._call = call;
  }
}

export class DeleteStreamCall extends ethereum.Call {
  get inputs(): DeleteStreamCall__Inputs {
    return new DeleteStreamCall__Inputs(this);
  }

  get outputs(): DeleteStreamCall__Outputs {
    return new DeleteStreamCall__Outputs(this);
  }
}

export class DeleteStreamCall__Inputs {
  _call: DeleteStreamCall;

  constructor(call: DeleteStreamCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DeleteStreamCall__Outputs {
  _call: DeleteStreamCall;

  constructor(call: DeleteStreamCall) {
    this._call = call;
  }
}

export class RebalanceCall extends ethereum.Call {
  get inputs(): RebalanceCall__Inputs {
    return new RebalanceCall__Inputs(this);
  }

  get outputs(): RebalanceCall__Outputs {
    return new RebalanceCall__Outputs(this);
  }
}

export class RebalanceCall__Inputs {
  _call: RebalanceCall;

  constructor(call: RebalanceCall) {
    this._call = call;
  }

  get destinationDomain(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get destinationContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class RebalanceCall__Outputs {
  _call: RebalanceCall;

  constructor(call: RebalanceCall) {
    this._call = call;
  }
}

export class ReceiveFlowMessageCall extends ethereum.Call {
  get inputs(): ReceiveFlowMessageCall__Inputs {
    return new ReceiveFlowMessageCall__Inputs(this);
  }

  get outputs(): ReceiveFlowMessageCall__Outputs {
    return new ReceiveFlowMessageCall__Outputs(this);
  }
}

export class ReceiveFlowMessageCall__Inputs {
  _call: ReceiveFlowMessageCall;

  constructor(call: ReceiveFlowMessageCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get flowRate(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get startTime(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ReceiveFlowMessageCall__Outputs {
  _call: ReceiveFlowMessageCall;

  constructor(call: ReceiveFlowMessageCall) {
    this._call = call;
  }
}

export class WithdrawFundsCall extends ethereum.Call {
  get inputs(): WithdrawFundsCall__Inputs {
    return new WithdrawFundsCall__Inputs(this);
  }

  get outputs(): WithdrawFundsCall__Outputs {
    return new WithdrawFundsCall__Outputs(this);
  }
}

export class WithdrawFundsCall__Inputs {
  _call: WithdrawFundsCall;

  constructor(call: WithdrawFundsCall) {
    this._call = call;
  }

  get _amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class WithdrawFundsCall__Outputs {
  _call: WithdrawFundsCall;

  constructor(call: WithdrawFundsCall) {
    this._call = call;
  }
}

export class XReceiveCall extends ethereum.Call {
  get inputs(): XReceiveCall__Inputs {
    return new XReceiveCall__Inputs(this);
  }

  get outputs(): XReceiveCall__Outputs {
    return new XReceiveCall__Outputs(this);
  }
}

export class XReceiveCall__Inputs {
  _call: XReceiveCall;

  constructor(call: XReceiveCall) {
    this._call = call;
  }

  get _transferId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _asset(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _originSender(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _origin(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _callData(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }
}

export class XReceiveCall__Outputs {
  _call: XReceiveCall;

  constructor(call: XReceiveCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}
